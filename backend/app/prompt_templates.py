"""
Шаблоны промптов для генерации тестов AI-агентом
"""
from enum import Enum
from dataclasses import dataclass
from typing import Optional, Dict, Any
import re


class TestType(str, Enum):
    """Типы тестов"""
    UI = "ui"
    API = "api"


class TestPriority(str, Enum):
    """Приоритеты тестов"""
    CRITICAL = "CRITICAL"
    HIGH = "HIGH"
    NORMAL = "NORMAL"
    LOW = "LOW"


@dataclass
class PromptTemplate:
    """Шаблон промпта"""
    system_role: str
    user_template: str
    temperature: float = 0.3
    max_tokens: int = 2048
    description: str = ""


def _slugify_path(path: str) -> str:
    """
    Преобразует путь API в slug для имени класса
    
    Пример:
        /api/v1/users/{id} -> api_v1_users_id
        /auth/login -> auth_login
    """
    # Убираем начальный и конечный слэши
    path = path.strip('/')
    # Заменяем все не-буквенно-цифровые символы на _
    path = re.sub(r'[^\w\-]', '_', path)
    # Заменяем множественные подчеркивания на одно
    path = re.sub(r'_+', '_', path)
    # Убираем начальное и конечное подчеркивание
    path = path.strip('_')
    # Если путь пустой, возвращаем 'root'
    return path if path else 'root'


class PromptTemplates:
    """Коллекция шаблонов промптов для AI-агента"""
    
    @staticmethod
    def get_system_role() -> str:
        """Базовая системная роль для всех промптов"""
        return (
            "Ты — Senior QA Automation Engineer с 10+ лет опыта. "
            "Ты специализируешься на генерации production-ready тестов на Python. "
            "Твой код должен быть чистым, читаемым и сразу готовым к запуску. "
            "Ты строго следуешь паттерну AAA (Arrange-Act-Assert). "
            "Ты всегда используешь Allure для отчетности. "
            "Ты пишешь тесты, которые легко поддерживать и расширять."
        )
    
    @staticmethod
    def testcase_generation(
        test_type: TestType,
        priority: TestPriority = TestPriority.NORMAL,
        framework: str = "pytest"
    ) -> PromptTemplate:
        """
        Шаблон для генерации тест-кейсов
        
        Args:
            test_type: Тип теста (UI/API)
            priority: Приоритет теста
            framework: Фреймворк тестирования
        """
        test_type_ru = "UI" if test_type == TestType.UI else "API"
        
        return PromptTemplate(
            system_role=PromptTemplates.get_system_role(),
            user_template=f"""Сгенерируй код тест-кейса на Python.

КОНТЕКСТ:
- Тип теста: {test_type_ru}
- Приоритет: {priority.value}
- Фреймворк: {framework}
- Отчетность: Allure TestOps

ТРЕБОВАНИЯ:
{{requirements}}

ИНСТРУКЦИИ:
1. Используй паттерн AAA (Arrange-Act-Assert)
2. Добавь Allure декораторы и степы
3. Напиши чистый, поддерживаемый код
4. Добавь обработку ошибок
5. Используй понятные имена переменных

ТРЕБОВАНИЯ К ФОРМАТУ:
1. Класс должен называться TestGenerated_[краткое_описание]
2. Все тестовые методы должны начинаться с test_
3. Обязательные Allure декораторы:
   - @allure.feature("[название_фичи]")
   - @allure.story("[название_стори]")
   - @allure.title("[человекочитаемое_название]")
   - @allure.tag("{priority.value}")
   - @allure.label("owner", "autogenerated")
   - @allure.label("source", "ai_agent_v1")

4. Каждый тест должен содержать:
   - Docstring с описанием
   - Шаг Arrange: подготовка данных
   - Шаг Act: выполнение действия
   - Шаг Assert: проверка результата

5. Для {test_type_ru} тестов:
   {"- Проверяй статус коды и структуру ответа" if test_type == TestType.API else "- Используй явные ожидания (explicit waits)"}
   {"- Добавь аутентификацию если требуется" if test_type == TestType.API else "- Проверяй видимость элементов"}

ВЕРНИ ТОЛЬКО PYTHON КОД, без пояснений, без markdown.""",
            temperature=0.2,  # Низкая температура для консистентности
            max_tokens=2500,
            description=f"Генерация {test_type_ru} тест-кейсов"
        )
    
    @staticmethod
    def api_autotest_generation(
        endpoint_info: Dict[str, Any],
        priority: TestPriority = TestPriority.CRITICAL
    ) -> PromptTemplate:
        """
        Шаблон для генерации API автотестов
        
        Args:
            endpoint_info: Информация об эндпоинте
            priority: Приоритет теста
        """
        method = endpoint_info.get("method", "GET")
        path = endpoint_info.get("path", "/")
        summary = endpoint_info.get("summary", "")
        
        # Создаем slug из пути для имени класса
        path_slug = _slugify_path(path)
        
        return PromptTemplate(
            system_role=(
                "Ты — Senior API Test Automation Engineer. "
                "Ты специализируешься на генерации надежных API тестов с использованием httpx. "
                "Ты знаешь все best practices для тестирования REST API."
            ),
            user_template=f"""Сгенерируй pytest тест для API эндпоинта.

ИНФОРМАЦИЯ О ЭНДПОИНТЕ:
- Метод: {method}
- Путь: {path}
- Описание: {summary}

OPENAPI СПЕЦИФИКАЦИЯ:
{{openapi_spec}}

ТРЕБОВАНИЯ К ТЕСТУ:
1. Используй httpx.AsyncClient для асинхронных запросов
2. Добавь Bearer аутентификацию через заголовок Authorization
3. Протестируй позитивные и негативные сценарии
4. Включи валидацию:
   - Статус кода ответа
   - JSON schema (если есть)
   - Время ответа < 3 секунд
   - Заголовки ответа
5. Используй параметризацию pytest для boundary testing
6. Добавь фикстуры для:
   - HTTP клиента
   - Аутентификации
   - Тестовых данных

ТРЕБОВАНИЯ К КОДУ:
1. Класс: TestAPI_{method}_{path_slug}
2. Методы: test_[scenario]_[status]
3. Allure декораторы:
   - @allure.feature("API Testing")
   - @allure.story("{path}")
   - @allure.title("{method} {path} - [scenario]")
   - @allure.tag("{priority.value}")
   - @allure.label("owner", "autogenerated")
   - @allure.label("api_version", "v1")

4. Добавь:
   - Обработку таймаутов
   - Логирование запросов/ответов
   - Retry логику для неустойчивых эндпоинтов
   - Параметризованные тесты для разных данных

ВЕРНИ ТОЛЬКО PYTHON КОД, готовый к запуску.""",
            temperature=0.3,
            max_tokens=3000,
            description=f"Генерация автотестов для {method} {path}"
        )
    
    @staticmethod
    def ui_autotest_generation(
        scenario: str,
        priority: TestPriority = TestPriority.NORMAL,
        framework: str = "playwright"
    ) -> PromptTemplate:
        """
        Шаблон для генерации UI автотестов
        
        Args:
            scenario: Описание сценария
            priority: Приоритет теста
            framework: Фреймворк (playwright/selenium)
        """
        return PromptTemplate(
            system_role=(
                f"Ты — Senior {framework.capitalize()} Test Automation Engineer. "
                "Ты специализируешься на генерации стабильных UI тестов. "
                "Ты знаешь все best practices для Page Object Model и явных ожиданий."
            ),
            user_template=f"""Сгенерируй UI тест на {framework} для следующего сценария:

СЦЕНАРИЙ:
{{scenario}}

ТРЕБОВАНИЯ К ТЕСТУ:
1. Используй {framework} с async/await
2. Применяй Page Object Model (POM)
3. Используй явные ожидания (explicit waits)
4. Добавь обработку:
   - Таймаутов
   - Элементов, которые не найдены
   - Поп-апов и алертов
5. Включи скриншоты при падении
6. Тестируй на разных разрешениях экрана

ТРЕБОВАНИЯ К КОДУ:
1. Класс: TestUI_[feature_name]
2. Методы: test_[scenario_name]
3. Используй фикстуры для:
   - Браузера/контекста
   - Тестовой страницы
   - Тестовых данных
4. Allure декораторы:
   - @allure.feature("UI Testing")
   - @allure.story("[feature_story]")
   - @allure.title("[human_readable_title]")
   - @allure.tag("{priority.value}")
   - @allure.label("owner", "autogenerated")
   - @allure.label("browser", "chromium")

5. Добавь:
   - Детальные шаги Allure
   - Логирование действий
   - Валидацию состояний
   - Очистку после тестов

КОМАНДЫ {framework.upper()} ДЛЯ ИСПОЛЬЗОВАНИЯ:
- page.goto(url)
- page.click(selector)
- page.fill(selector, text)
- page.wait_for_selector(selector)
- expect(locator).to_be_visible()
- expect(locator).to_have_text(text)

ВЕРНИ ТОЛЬКО PYTHON КОД, готовый к запуску.""",
            temperature=0.25,
            max_tokens=3500,
            description=f"Генерация UI тестов на {framework}"
        )
    
    @staticmethod
    def code_validation() -> PromptTemplate:
        """Шаблон для валидации Python кода тестов"""
        return PromptTemplate(
            system_role=(
                "Ты — Senior Code Reviewer для Python тестов. "
                "Ты проверяешь код на соответствие best practices, "
                "читаемость, поддерживаемость и наличие ошибок."
            ),
            user_template="""Проверь следующий Python код тестов и предоставь детальный анализ:

КОД ДЛЯ ПРОВЕРКИ:
{{code}}

ПРОВЕРЬ СЛЕДУЮЩИЕ АСПЕКТЫ:
1. Синтаксические ошибки
2. Соответствие PEP 8
3. Наличие Allure декораторов и степов
4. Корректность паттерна AAA
5. Обработку ошибок и исключений
6. Качество assertions
7. Повторное использование кода
8. Читаемость имен переменных и функций
9. Наличие docstring и комментариев
10. Оптимальность использования ресурсов

ФОРМАТ ОТВЕТА:
1. Список критических проблем (ошибки)
2. Список рекомендаций (улучшения)
3. Общая оценка кода (1-10)
4. Конкретные исправления

ВЕРНИ АНАЛИЗ В MARKDOWN ФОРМАТЕ.""",
            temperature=0.1,
            max_tokens=2000,
            description="Валидация Python кода тестов"
        )


# Экспорт удобных функций
def get_testcase_prompt(
    requirements: str, 
    test_type: TestType = TestType.API,
    priority: TestPriority = TestPriority.NORMAL
) -> tuple[str, Dict[str, Any]]:
    """Получить промпт для генерации тест-кейса"""
    template = PromptTemplates.testcase_generation(test_type, priority)
    
    prompt = template.user_template.format(requirements=requirements)
    params = {
        "temperature": template.temperature,
        "max_tokens": template.max_tokens,
        "system_role": template.system_role
    }
    
    return prompt, params


def get_api_autotest_prompt(
    openapi_spec: str,
    endpoint_info: Dict[str, Any],
    priority: TestPriority = TestPriority.CRITICAL
) -> tuple[str, Dict[str, Any]]:
    """Получить промпт для генерации API автотеста"""
    # Создаем slug для имени класса
    path = endpoint_info.get("path", "/")
    path_slug = _slugify_path(path)
    endpoint_info_with_slug = endpoint_info.copy()
    endpoint_info_with_slug["path_slug"] = path_slug
    
    template = PromptTemplates.api_autotest_generation(endpoint_info_with_slug, priority)
    
    prompt = template.user_template.format(openapi_spec=openapi_spec)
    params = {
        "temperature": template.temperature,
        "max_tokens": template.max_tokens,
        "system_role": template.system_role
    }
    
    return prompt, params


def get_ui_autotest_prompt(
    scenario: str,
    priority: TestPriority = TestPriority.NORMAL,
    framework: str = "playwright"
) -> tuple[str, Dict[str, Any]]:
    """Получить промпт для генерации UI автотеста"""
    template = PromptTemplates.ui_autotest_generation(scenario, priority, framework)
    
    prompt = template.user_template.format(scenario=scenario)
    params = {
        "temperature": template.temperature,
        "max_tokens": template.max_tokens,
        "system_role": template.system_role
    }
    
    return prompt, params